# -*- coding: utf-8 -*-
"""Entrega2DadosPicMoney

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10ntE_t3RZ1CkfmSUS09BdzODKPGG_wtH
"""

# ============================================
# üöÄ ETAPA DE PREPARA√á√ÉO DE DADOS - EXEMPLO
# ============================================

import pandas as pd
import numpy as np
from datetime import datetime

# --- 1Ô∏è‚É£ CARREGAR DADOS -------------------------------------------------------

# Exemplo: substitua 'dados_brutos.csv' pelo seu arquivo real
df = pd.read_csv('/content/PicMoney-Base_Cadastral_de_Players-10_000 linhas (1).csv', sep=';')

print("Registros iniciais:", len(df))

# --- 2Ô∏è‚É£ LIMPEZA --------------------------------------------------------------

# Remover duplicatas
df = df.drop_duplicates()

# Tratar valores ausentes
cols_local = ['cidade_trabalho', 'bairro_trabalho', 'cidade_escola', 'bairro_escola']
df[cols_local] = df[cols_local].fillna('N√£o informado')

# Padronizar cidade_residencial e bairro_residencial se houver NaN
df['cidade_residencial'] = df['cidade_residencial'].fillna('N√£o informado')
df['bairro_residencial'] = df['bairro_residencial'].fillna('N√£o informado')

# Converter data de nascimento
df['data_nascimento'] = pd.to_datetime(df['data_nascimento'], errors='coerce', dayfirst=True)

# Recalcular idade, se desejar garantir consist√™ncia
df['idade_corrigida'] = df['data_nascimento'].apply(
    lambda x: datetime.now().year - x.year if pd.notnull(x) else np.nan
)
# Substituir idade original se houver diferen√ßa grande
df['idade'] = np.where(abs(df['idade'] - df['idade_corrigida']) > 1,
                       df['idade_corrigida'], df['idade'])
df = df.drop(columns=['idade_corrigida'])

# --- 3Ô∏è‚É£ UNIFORMIZA√á√ÉO --------------------------------------------------------

# Celular: remover caracteres n√£o num√©ricos e padronizar formato
df['celular'] = (
    df['celular'].astype(str)
    .str.replace(r'\D', '', regex=True)
    .apply(lambda x: f"({x[:2]}) {x[2:7]}-{x[7:]}" if len(x) == 11 else x)
)

# Sexo: capitalizar e corrigir variantes
df['sexo'] = (
    df['sexo']
    .astype(str)
    .str.strip()
    .str.capitalize()
    .replace({'Masc': 'Masculino', 'Fem': 'Feminino'})
)

# Cidades e bairros: capitaliza√ß√£o correta
for col in ['cidade_residencial', 'bairro_residencial',
            'cidade_trabalho', 'bairro_trabalho',
            'cidade_escola', 'bairro_escola']:
    df[col] = df[col].astype(str).str.title().str.strip()

# Categoria: padronizar capitaliza√ß√£o
df['categoria_frequentada'] = df['categoria_frequentada'].astype(str).str.title().str.strip()

# --- 4Ô∏è‚É£ DERIVA√á√ÉO ------------------------------------------------------------

# Criar faixa etaria
bins = [0, 17, 29, 44, 59, 74, 120]
labels = ['0-17', '18-29', '30-44', '45-59', '60-74', '75+']
df['faixa_etaria'] = pd.cut(df['idade'], bins=bins, labels=labels, right=False)

# Indicador de locais conhecidos
df['tem_dados_completos'] = df[cols_local].apply(lambda x: x.ne('N√£o informado').any(), axis=1)

# --- 5Ô∏è‚É£ INTEGRA√á√ÉO SIMPLES (opcional) ---------------------------------------

# Exemplo: agrupar categorias em segmentos
map_categorias = {
    'Farm√°cias E Drogarias': 'Sa√∫de',
    'Cl√≠nicas De Sa√∫de E Bem-Estar': 'Sa√∫de',
    'Supermercados De Bairro E Mercadinhos': 'Alimenta√ß√£o',
    'Restaurantes E Gastronomia': 'Alimenta√ß√£o',
    'Postos De Combust√≠vel E Servi√ßos Automotivos': 'Servi√ßos',
    'Lojas De Roupas E Cal√ßados': 'Varejo',
    'Clubes E Centros De Conviv√™ncia': 'Lazer'
}
df['segmento'] = df['categoria_frequentada'].replace(map_categorias)

# --- 6Ô∏è‚É£ FORMATA√á√ÉO FINAL -----------------------------------------------------

# Ordenar colunas
cols_final = [
    'celular', 'sexo', 'data_nascimento', 'idade', 'faixa_etaria',
    'cidade_residencial', 'bairro_residencial',
    'cidade_trabalho', 'bairro_trabalho',
    'cidade_escola', 'bairro_escola',
    'categoria_frequentada', 'segmento', 'tem_dados_completos'
]
df = df[cols_final]

# Converter tipos
df['idade'] = df['idade'].astype('Int64')

# Exportar
df.to_csv('dados_limpos.csv', index=False, encoding='utf-8-sig')

print("‚úÖ Limpeza conclu√≠da com sucesso!")
print("Registros finais:", len(df))
print("Arquivo salvo como 'dados_limpos.csv'")

import pandas as pd
import numpy as np

# Load the data with score_engajamento - assuming 'celular' is a common key
df_scores = pd.read_csv('/content/PicMoney-Massa_de_Teste_com_Lojas_e_Valores-10000 linhas.csv', sep=';')

# Rename 'numero_celular' to 'celular' in df_scores for merging
df_scores = df_scores.rename(columns={'numero_celular': 'celular'})

# Merge with the existing df
# Assuming 'celular' is the key for merging. Adjust if a different key is needed.
# Removed merge involving score_engajamento as it's not available
# df = pd.merge(df, df_scores[['celular', 'score_engajamento']], on='celular', how='left')


# --- 1Ô∏è‚É£ LIMPEZA E PADRONIZA√á√ÉO ----------------------------------------------

# Celular: limpar e padronizar
df['celular'] = (
    df['celular'].astype(str)
    .str.replace(r'\D', '', regex=True)
    .apply(lambda x: f"({x[:2]}) {x[2:7]}-{x[7:]}" if len(x) == 11 else x)
)

# Sexo: padronizar
df['sexo'] = (
    df['sexo']
    .astype(str)
    .str.strip()
    .str.capitalize()
    .replace({'Masc': 'Masculino', 'Fem': 'Feminino', 'Outro': 'Outro'})
)

# Bairro: capitalizar
df['bairro_residencial'] = df['bairro_residencial'].astype(str).str.title().str.strip()

# Categoria: padronizar capitaliza√ß√£o
df['categoria_frequentada'] = df['categoria_frequentada'].astype(str).str.title().str.strip()

# Score: garantir tipo num√©rico - Removed as score_engajamento is not available
# df['score_engajamento'] = pd.to_numeric(df['score_engajamento'], errors='coerce')

# --- 2Ô∏è‚É£ DERIVA√á√ÉO ------------------------------------------------------------

# Faixa et√°ria
bins = [0, 17, 29, 44, 59, 74, 120]
labels = ['0-17', '18-29', '30-44', '45-59', '60-74', '75+']
df['faixa_etaria'] = pd.cut(df['idade'], bins=bins, labels=labels, right=False)

# Segmento simplificado de categorias
map_categorias = {
    'Farm√°cias E Drogarias': 'Sa√∫de',
    'Cl√≠nicas M√©dicas E Laborat√≥rios': 'Sa√∫de',
    'Produtos Naturais E Fitoter√°picos': 'Sa√∫de',
    'Supermercados De Bairro E Mercadinhos': 'Alimenta√ß√£o',
    'Supermercados E Mercados Express': 'Alimenta√ß√£o',
    'Restaurantes Com Comida Caseira': 'Alimenta√ß√£o',
    'Lojas De Roupas E Cal√ßados': 'Varejo',
    'Cal√ßados Confort√°veis E Ortop√©dicos': 'Varejo',
    'Lojas De M√≥veis E Decora√ß√£o': 'Varejo',
    'Lojas De Eletrodom√©sticos E Utilidades Dom√©sticas': 'Varejo',
    'Lojas De Eletr√¥nicos E Games': 'Varejo',
    'Barbearias/Sal√µes Com Est√©tica Jovem': 'Servi√ßos',
    'Clubes E Centros De Conviv√™ncia': 'Lazer',
    'Academias E Studios Fitness': 'Lazer',
    'Bancos, Ag√™ncias E Correspondentes': 'Servi√ßos',
    'Papelarias, Livrarias E Lojas De Escrit√≥rio': 'Servi√ßos'
}
df['segmento'] = df['categoria_frequentada'].replace(map_categorias)

# --- 3Ô∏è‚É£ NOVO: DETEC√á√ÉO DE CIDADE PELO DDD -----------------------------------

map_ddd = {
    '11': 'S√£o Paulo',
    '12': 'S√£o Jos√© dos Campos',
    '13': 'Santos',
    '15': 'Sorocaba',
    '16': 'Ribeir√£o Preto',
    '17': 'S√£o Jos√© do Rio Preto',
    '18': 'Presidente Prudente',
    '19': 'Campinas',
    '21': 'Rio de Janeiro',
    '27': 'Vit√≥ria',
    '31': 'Belo Horizonte',
    '41': 'Curitiba'
}

df['ddd'] = df['celular'].str.extract(r'\((\d{2})\)')
df['cidade_por_ddd'] = df['ddd'].map(map_ddd).fillna('Desconhecida')

# --- 4Ô∏è‚É£ NOVO: CLASSIFICA√á√ÉO DE ENGAJAMENTO -----------------------------------

# Removed classification based on score_engajamento

# --- 5Ô∏è‚É£ FORMATA√á√ÉO FINAL -----------------------------------------------------

cols_final = [
    'celular', 'ddd', 'cidade_por_ddd', 'sexo', 'idade', 'faixa_etaria',
    'bairro_residencial', 'categoria_frequentada', 'segmento'
    # Removed score_engajamento and nivel_engajamento from final columns
    # 'score_engajamento', 'nivel_engajamento'
]
df = df[cols_final]

df['idade'] = df['idade'].astype('Int64')

# --- 6Ô∏è‚É£ EXPORTAR -------------------------------------------------------------

df.to_csv('dados_com_ddd_e_engajamento.csv', index=False, encoding='utf-8-sig')

print("‚úÖ Dados enriquecidos com cidade e n√≠vel de engajamento!")
print(df.head(10))

import pandas as pd

df_scores = pd.read_csv('/content/PicMoney-Massa_de_Teste_com_Lojas_e_Valores-10000 linhas.csv', sep=';')
print(df_scores.columns)

import pandas as pd
import numpy as np

# --- 1Ô∏è‚É£ AJUSTAR COLUNAS SUFIXADAS --------------------------------------------

# Corrigir nomes de colunas resultantes de merges (_x, _y)
df = df.rename(columns=lambda x: x.replace('_y', '') if x.endswith('_y') else x)
df = df.loc[:, ~df.columns.str.endswith('_x')]

# --- 2Ô∏è‚É£ LIMPEZA DE IDADE E SEXO ---------------------------------------------

df['idade'] = pd.to_numeric(df['idade'], errors='coerce')
df = df[df['idade'].between(16, 100)]  # filtro de faixa et√°ria v√°lida

# Padroniza√ß√£o de sexo
df['sexo'] = (
    df['sexo']
    .astype(str)
    .str.strip()
    .str.capitalize()
    .replace({
        'M': 'Masculino',
        'F': 'Feminino',
        'Outro': 'Outro',
        'Outros': 'Outro',
        'N√£o Informado': 'Outro',
        'Na': 'Outro',
        'Nan': 'Outro'
    })
)

# --- 3Ô∏è‚É£ DERIVA√á√ÉO DE FAIXA ET√ÅRIA -------------------------------------------

bins = [0, 17, 29, 44, 59, 74, 120]
labels = ['0-17', '18-29', '30-44', '45-59', '60-74', '75+']
df['faixa_etaria'] = pd.cut(df['idade'], bins=bins, labels=labels, right=False)

# --- 4Ô∏è‚É£ CLASSIFICA√á√ÉO DE ENGAJAMENTO ----------------------------------------

def classificar_engajamento(score):
    if pd.isna(score):
        return 'Desconhecido'
    elif score >= 170:
        return 'Alto'
    elif score >= 145:
        return 'M√©dio'
    else:
        return 'Baixo'

if 'score_engajamento' in df.columns:
    df['score_engajamento'] = pd.to_numeric(df['score_engajamento'], errors='coerce')
    df['nivel_engajamento'] = df['score_engajamento'].apply(classificar_engajamento)

# --- 5Ô∏è‚É£ RELAT√ìRIO DE QUALIDADE ----------------------------------------------

print("\n==================== üìä RELAT√ìRIO DE QUALIDADE DOS DADOS ====================\n")

# 5.1. Valores ausentes (%)
missing_report = df.isnull().mean() * 100
print("üîπ Percentual de valores ausentes por coluna (%):")
print(missing_report.round(2))
print("-----------------------------------------------------------------------------\n")

# 5.2. Estat√≠sticas descritivas de idade
if 'idade' in df.columns:
    print("üìà Estat√≠sticas de idade:")
    print(df['idade'].describe().round(2))
    print("-----------------------------------------------------------------------------\n")

# 5.3. Distribui√ß√£o de faixas et√°rias
if 'faixa_etaria' in df.columns:
    print("üìä Distribui√ß√£o por faixa et√°ria:")
    print(df['faixa_etaria'].value_counts().sort_index())
    print("-----------------------------------------------------------------------------\n")

# 5.4. Distribui√ß√£o de sexo
if 'sexo' in df.columns:
    print("üë§ Distribui√ß√£o de sexo:")
    print(df['sexo'].value_counts())
    print("-----------------------------------------------------------------------------\n")

# 5.5. Distribui√ß√£o de engajamento
if 'nivel_engajamento' in df.columns:
    print("üî• Distribui√ß√£o de n√≠vel de engajamento:")
    print(df['nivel_engajamento'].value_counts())
    print("-----------------------------------------------------------------------------\n")

# 5.6. Estat√≠sticas do score de engajamento
if 'score_engajamento' in df.columns:
    print("üí¨ Estat√≠sticas do score de engajamento:")
    print(df['score_engajamento'].describe().round(2))
    print("-----------------------------------------------------------------------------\n")

# 5.7. Correla√ß√£o idade x score
if {'idade', 'score_engajamento'}.issubset(df.columns):
    corr = df[['idade', 'score_engajamento']].corr().iloc[0, 1]
    print(f"üîó Correla√ß√£o entre idade e score de engajamento: {corr:.3f}")
    if abs(corr) < 0.2:
        print("‚û°Ô∏è Correla√ß√£o fraca (quase independente).")
    elif abs(corr) < 0.5:
        print("‚û°Ô∏è Correla√ß√£o moderada.")
    else:
        print("‚û°Ô∏è Correla√ß√£o forte.")
    print("-----------------------------------------------------------------------------\n")

# 5.8. An√°lise de poss√≠veis anomalias
anomalias = df[(df['idade'] < 18) | (df['idade'] > 85)]
print(f"‚ö†Ô∏è Registros com idades possivelmente an√¥malas: {len(anomalias)}")
if not anomalias.empty:
    print(anomalias[['celular', 'idade', 'sexo']].head())
print("-----------------------------------------------------------------------------\n")

print("‚úÖ Relat√≥rio conclu√≠do e base limpa para an√°lise!")
print(f"üìÅ Total de registros finais: {len(df)}")

# --- 6Ô∏è‚É£ EXPORTA√á√ÉO FINAL -----------------------------------------------------

df.to_csv('dados_pos_merge_relatorio.csv', index=False, encoding='utf-8-sig')
print("\nüì¶ Arquivo salvo como 'dados_pos_merge_relatorio.csv'")

pip install pandas matplotlib seaborn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from datetime import datetime

# --- 1Ô∏è‚É£ ESTRUTURA -------------------------------------------------------------
print("\n==================== üßæ ESTRUTURA DE DADOS ====================")
print(df.dtypes)
print("---------------------------------------------------------------")

# --- 2Ô∏è‚É£ COER√äNCIA ENTRE IDADE E DATA -----------------------------------------
# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# Removed check for inconsistencies based on age difference
# inconsistentes = df[df['dif_idade'].abs() > 1]
# print(f"\n‚ö†Ô∏è Registros com diferen√ßa entre idade e data_nascimento: {len(inconsistentes)}")
# if len(inconsistentes) > 0:
#     print(inconsistentes[['celular', 'data_nascimento', 'idade', 'idade_calc', 'dif_idade']].head())
# print("---------------------------------------------------------------")

# --- 3Ô∏è‚É£ COMPLETUDE ------------------------------------------------------------
missing_report = df.isnull().mean() * 100
print("\nüìâ Percentual de valores ausentes (%):")
print(missing_report.round(2))
print("---------------------------------------------------------------")

# --- 4Ô∏è‚É£ CARDINALIDADE ---------------------------------------------------------
print("\nüî¢ Cardinalidade (valores √∫nicos por coluna):")
print(df.nunique().sort_values(ascending=False))
print("---------------------------------------------------------------")

# --- 5Ô∏è‚É£ DISTRIBUI√á√ïES ---------------------------------------------------------
print("\nüìä Distribui√ß√£o de sexo:")
print(df['sexo'].value_counts())
print("---------------------------------------------------------------")

print("\nüìà Top 10 categorias frequentadas:")
print(df['categoria_frequentada'].value_counts().head(10))
print("---------------------------------------------------------------")

# Removed printing Top 5 cidades residenciais as the column is not available
# print("\nüèôÔ∏è Top 5 cidades residenciais:")
# print(df['cidade_residencial'].value_counts().head(5))
# print("---------------------------------------------------------------")

# --- 6Ô∏è‚É£ ESTAT√çSTICAS DE IDADE -------------------------------------------------
print("\nüìâ Estat√≠sticas descritivas de idade:")
print(df['idade'].describe().round(2))
print("---------------------------------------------------------------")

# --- 7Ô∏è‚É£ √çNDICE DE COMPLETUDE GERAL -------------------------------------------
completude_total = 100 - (missing_report.mean())
print(f"\n‚úÖ √çndice m√©dio de completude da base: {completude_total:.2f}%")
if completude_total > 95:
    print("üîµ Excelente qualidade de dados (quase completa).")
elif completude_total > 85:
    print("üü° Boa, mas pode melhorar.")
else:
    print("üî¥ Aten√ß√£o: muitos dados ausentes.")
print("---------------------------------------------------------------")

# --- 8Ô∏è‚É£ VISUALIZA√á√ïES --------------------------------------------------------

plt.style.use("seaborn-v0_8-whitegrid")
sns.set_palette("Set2")

fig, axes = plt.subplots(2, 2, figsize=(14, 10))
fig.suptitle("üìä Relat√≥rio Visual de Qualidade e Distribui√ß√£o dos Dados", fontsize=16, fontweight='bold')

# üîπ 1. Histograma da idade
sns.histplot(df['idade'], bins=20, kde=True, ax=axes[0,0])
axes[0,0].set_title("Distribui√ß√£o de Idade")
axes[0,0].set_xlabel("Idade")
axes[0,0].set_ylabel("Frequ√™ncia")

# üîπ 2. Sexo - gr√°fico de pizza
df['sexo'].value_counts().plot.pie(
    autopct='%1.1f%%', ax=axes[0,1], startangle=90, colors=sns.color_palette("pastel"))
axes[0,1].set_ylabel("")
axes[0,1].set_title("Distribui√ß√£o de Sexo")

# üîπ 3. Categorias mais frequentes
top_categorias = df['categoria_frequentada'].value_counts().head(10)
sns.barplot(y=top_categorias.index, x=top_categorias.values, ax=axes[1,0])
axes[1,0].set_title("Top 10 Categorias Frequentadas")
axes[1,0].set_xlabel("Contagem")
axes[1,0].set_ylabel("Categoria")

# üîπ 4. Heatmap de completude
sns.heatmap(df.notnull(), cbar=False, ax=axes[1,1], cmap=["#FFCCCC", "#B2FFB2"])
axes[1,1].set_title("Mapa de Completude (verde = dados v√°lidos)")

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

# --- 9Ô∏è‚É£ COER√äNCIA TEMPORAL ---------------------------------------------------
# Removed correlation plot as idade_calc is not available
# plt.figure(figsize=(8,5))
# sns.scatterplot(x='idade_calc', y='idade', data=df, alpha=0.5)
# plt.title("Correla√ß√£o Idade x Idade Calculada")
# plt.xlabel("Idade calculada (a partir da data de nascimento)")
# plt.ylabel("Idade informada")
# plt.grid(True)
# plt.show()

# --- 10Ô∏è‚É£ EXPORTA√á√ÉO -------------------------------------------------------------
df.to_csv('dados_validados_com_graficos.csv', index=False, encoding='utf-8-sig')
print("\nüì¶ Arquivo final salvo como 'dados_validados_com_graficos.csv'")
print("‚úÖ Relat√≥rio visual conclu√≠do!")

pip install plotly

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime

# üßπ Garantir que a idade calculada e diferen√ßa estejam corretas
# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# ====================== üìä 1Ô∏è‚É£ HISTOGRAMA INTERATIVO DE IDADE ======================
fig1 = px.histogram(
    df,
    x="idade",
    nbins=20,
    color_discrete_sequence=["#6ab7ff"],
    title="Distribui√ß√£o de Idade (Interativo)",
    labels={"idade": "Idade", "count": "Frequ√™ncia"}
)
fig1.update_layout(bargap=0.1)
fig1.show()

# ====================== üßç 2Ô∏è‚É£ GR√ÅFICO DE PIZZA - SEXO ======================
fig2 = px.pie(
    df,
    names="sexo",
    title="Distribui√ß√£o de Sexo (Interativo)",
    color_discrete_sequence=px.colors.qualitative.Pastel
)
fig2.update_traces(textinfo='percent+label', pull=[0.05, 0.05, 0.05])
fig2.show()

# ====================== üõçÔ∏è 3Ô∏è‚É£ TOP 10 CATEGORIAS ======================
top_categorias = df['categoria_frequentada'].value_counts().nlargest(10).reset_index()
top_categorias.columns = ['categoria_frequentada', 'contagem']

fig3 = px.bar(
    top_categorias,
    x='contagem',
    y='categoria_frequentada',
    orientation='h',
    text='contagem',
    title="Top 10 Categorias Frequentadas (Interativo)",
    color='contagem',
    color_continuous_scale='Blues'
)
fig3.update_traces(texttemplate='%{text}', textposition='outside')
fig3.update_layout(yaxis={'categoryorder':'total ascending'})
fig3.show()

# ====================== üîó 4Ô∏è‚É£ DISPERS√ÉO IDADE X IDADE CALCULADA ======================
# Removed scatter plot as idade_calc is not available
# fig4 = px.scatter(
#     df,
#     x='idade_calc',
#     y='idade',
#     color='sexo',
#     hover_data=['celular', 'bairro_residencial', 'categoria_frequentada'],
#     title="Correla√ß√£o: Idade Informada x Idade Calculada (Interativo)",
#     color_discrete_sequence=px.colors.qualitative.Set2
# )
# fig4.add_shape(
#     type='line',
#     x0=df['idade_calc'].min(),
#     y0=df['idade_calc'].min(),
#     x1=df['idade_calc'].max(),
#     y1=df['idade_calc'].max(),
#     line=dict(color='gray', dash='dash')
# )
# fig4.show()

# ====================== üó∫Ô∏è 5Ô∏è‚É£ HEATMAP DE COMPLETUDE ======================
missing = df.isnull().melt(var_name='coluna', value_name='ausente')
missing['presenca'] = missing['ausente'].apply(lambda x: 0 if x else 1)
heatmap_data = (
    missing.groupby('coluna')['presenca']
    .mean()
    .reset_index()
    .sort_values('presenca', ascending=False)
)

fig5 = px.bar(
    heatmap_data,
    x='presenca',
    y='coluna',
    orientation='h',
    color='presenca',
    color_continuous_scale='Greens',
    title="Completude dos Dados por Coluna (Interativo)",
    labels={'presenca': 'Propor√ß√£o de preenchimento'}
)
fig5.update_layout(xaxis_tickformat='.0%', xaxis_title="Completude (%)")
fig5.show()

# ====================== üíæ EXPORTA√á√ÉO OPCIONAL ======================
df.to_csv('dados_relatorio_interativo.csv', index=False, encoding='utf-8-sig')
print("\nüì¶ Arquivo salvo como 'dados_relatorio_interativo.csv'")
print("‚úÖ Relat√≥rio interativo completo gerado com sucesso!")

# üí° Salve este arquivo como dashboard.py e rode: streamlit run dashboard.py

import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime

# ---------- CARREGAR DADOS ----------
df = pd.read_csv('dados_relatorio_interativo.csv')

# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

st.title("üìä Dashboard Interativo de Usu√°rios")

# ---------- FILTROS ----------
sexo_filter = st.multiselect("Selecione o sexo:", options=df['sexo'].unique(), default=df['sexo'].unique())
df_filtrado = df[df['sexo'].isin(sexo_filter)]

idade_range = st.slider("Selecione faixa et√°ria:", int(df['idade'].min()), int(df['idade'].max()), (int(df['idade'].min()), int(df['idade'].max())))
df_filtrado = df_filtrado[(df_filtrado['idade'] >= idade_range[0]) & (df_filtrado['idade'] <= idade_range[1])]

# ---------- GR√ÅFICOS ----------
# Histograma de idade
st.subheader("üìà Distribui√ß√£o de Idade")
fig1 = px.histogram(df_filtrado, x="idade", nbins=20, title="Distribui√ß√£o de Idade")
st.plotly_chart(fig1, use_container_width=True)

# Pizza de sexo
st.subheader("üßç Distribui√ß√£o de Sexo")
fig2 = px.pie(df_filtrado, names="sexo", title="Distribui√ß√£o de Sexo")
st.plotly_chart(fig2, use_container_width=True)

# Top 10 categorias
st.subheader("üõçÔ∏è Top 10 Categorias Frequentadas")
top_categorias = df_filtrado['categoria_frequentada'].value_counts().nlargest(10).reset_index()
top_categorias.columns = ['categoria_frequentada', 'contagem']
fig3 = px.bar(top_categorias, x='contagem', y='categoria_frequentada', orientation='h', text='contagem')
st.plotly_chart(fig3, use_container_width=True)

# Dispers√£o idade x idade_calc
st.subheader("üîó Idade Informada x Idade Calculada")
# Removed scatter plot as idade_calc is not available
# fig4 = px.scatter(df_filtrado, x='idade_calc', y='idade', color='sexo', hover_data=['celular','bairro_residencial'])
# st.plotly_chart(fig4, use_container_width=True)

# Completude
st.subheader("üó∫Ô∏è Completude dos Dados")
missing = df_filtrado.isnull().melt(var_name='coluna', value_name='ausente')
missing['presenca'] = missing['ausente'].apply(lambda x: 0 if x else 1)
heatmap_data = missing.groupby('coluna')['presenca'].mean().reset_index().sort_values('presenca', ascending=False)
fig5 = px.bar(heatmap_data, x='presenca', y='coluna', orientation='h', color='presenca', color_continuous_scale='Greens', labels={'presenca':'Propor√ß√£o de preenchimento'})
st.plotly_chart(fig5, use_container_width=True)

pip install streamlit

import plotly.io as pio

# Lista de figuras criadas anteriormente
figuras = [fig1, fig2, fig3, fig5]

# Define names for the figures based on their content
figure_names = ["idade_histogram", "sexo_pie_chart", "top_categories_bar_chart", "completeness_heatmap"]

# Save each figure to a separate HTML interactive file
for i, fig in enumerate(figuras):
    file_name = f'{figure_names[i]}_interactive.html'
    pio.write_html(fig, file=file_name, auto_open=False) # Set auto_open to False to avoid opening multiple tabs
    print(f"‚úÖ Relat√≥rio HTML interativo gerado: {file_name}")

# Removed the line attempting to save the list of figures
# pio.write_html(figuras, file='relatorio_interativo.html', auto_open=True)
# print("‚úÖ Relat√≥rio HTML interativo gerado: relatorio_interativo.html")

# =================== IMPORTS ===================
import pandas as pd
import plotly.express as px
import plotly.io as pio
import streamlit as st
from datetime import datetime

# =================== CARREGAR DADOS ===================
# Substitua pelo caminho do seu CSV
df = pd.read_csv('dados_relatorio_interativo.csv')

# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# =================== DASHBOARD STREAMLIT ===================
st.title("üìä Dashboard Interativo de Usu√°rios")

# ----- FILTROS -----
sexo_filter = st.multiselect("Selecione o sexo:", options=df['sexo'].unique(), default=df['sexo'].unique())
df_filtrado = df[df['sexo'].isin(sexo_filter)]

idade_range = st.slider("Selecione faixa et√°ria:", int(df['idade'].min()), int(df['idade'].max()), (int(df['idade'].min()), int(df['idade'].max())))
df_filtrado = df_filtrado[(df_filtrado['idade'] >= idade_range[0]) & (df_filtrado['idade'] <= idade_range[1])]

# ----- GR√ÅFICOS -----
# 1Ô∏è‚É£ Histograma de idade
st.subheader("üìà Distribui√ß√£o de Idade")
fig1 = px.histogram(df_filtrado, x="idade", nbins=20, title="Distribui√ß√£o de Idade", color_discrete_sequence=["#6ab7ff"])
st.plotly_chart(fig1, use_container_width=True)

# 2Ô∏è‚É£ Pizza de sexo
st.subheader("üßç Distribui√ß√£o de Sexo")
fig2 = px.pie(df_filtrado, names="sexo", title="Distribui√ß√£o de Sexo", color_discrete_sequence=px.colors.qualitative.Pastel)
st.plotly_chart(fig2, use_container_width=True)

# 3Ô∏è‚É£ Top 10 categorias frequentadas
st.subheader("üõçÔ∏è Top 10 Categorias Frequentadas")
top_categorias = df_filtrado['categoria_frequentada'].value_counts().nlargest(10).reset_index()
top_categorias.columns = ['categoria_frequentada', 'contagem']
fig3 = px.bar(top_categorias, x='contagem', y='categoria_frequentada', orientation='h', text='contagem', color='contagem', color_continuous_scale='Blues')
fig3.update_traces(texttemplate='%{text}', textposition='outside')
fig3.update_layout(yaxis={'categoryorder':'total ascending'})
st.plotly_chart(fig3, use_container_width=True)

# 4Ô∏è‚É£ Dispers√£o idade x idade_calc
st.subheader("üîó Idade Informada x Idade Calculada")
# Removed scatter plot as idade_calc is not available
# fig4 = px.scatter(df_filtrado, x='idade_calc', y='idade', color='sexo', hover_data=['celular','bairro_residencial'])
# st.plotly_chart(fig4, use_container_width=True)

# 5Ô∏è‚É£ Completude dos dados
st.subheader("üó∫Ô∏è Completude dos Dados")
missing = df_filtrado.isnull().melt(var_name='coluna', value_name='ausente')
missing['presenca'] = missing['ausente'].apply(lambda x: 0 if x else 1)
heatmap_data = missing.groupby('coluna')['presenca'].mean().reset_index().sort_values('presenca', ascending=False)
fig5 = px.bar(heatmap_data, x='presenca', y='coluna', orientation='h', color='presenca', color_continuous_scale='Greens', labels={'presenca':'Propor√ß√£o de preenchimento'})
st.plotly_chart(fig5, use_container_width=True)

# =================== EXPORTA√á√ÉO ===================
# Salvar dados filtrados
df_filtrado.to_csv('dados_filtrados.csv', index=False, encoding='utf-8-sig')
st.success("üì¶ Dados filtrados salvos como 'dados_filtrados.csv'")

# Salvar relat√≥rio HTML interativo
# Removed fig4 as it was removed from the plots section
# pio.write_html([fig1, fig2, fig3, fig4, fig5], file='relatorio_interativo.html', auto_open=False)
# Removed saving all figures to one HTML as it's not directly supported
# st.success("‚úÖ Relat√≥rio HTML interativo gerado: 'relatorio_interativo.html'")

# =================== IMPORTS ===================
import pandas as pd
import plotly.express as px
import plotly.io as pio
import streamlit as st
from datetime import datetime

# =================== CARREGAR DADOS ===================
df = pd.read_csv('dados_relatorio_interativo.csv')

# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# =================== SIDEBAR FILTROS ===================
st.sidebar.title("Filtros")
sexo_filter = st.sidebar.multiselect(
    "Selecione o sexo:",
    options=df['sexo'].unique(),
    default=df['sexo'].unique()
)
idade_range = st.sidebar.slider(
    "Selecione faixa et√°ria:",
    int(df['idade'].min()), int(df['idade'].max()),
    (int(df['idade'].min()), int(df['idade'].max()))
)

df_filtrado = df[
    (df['sexo'].isin(sexo_filter)) &
    (df['idade'] >= idade_range[0]) &
    (df['idade'] <= idade_range[1])
]

# =================== T√çTULO ===================
st.title("üìä Dashboard Profissional de Usu√°rios")

# =================== ABAS ===================
# Removed "Idade vs Calculada" tab as the plot is removed
tabs = st.tabs(["Resumo Estat√≠stico", "Idade", "Sexo", "Categorias"])

# ----- Aba 1: Resumo Estat√≠stico -----
with tabs[0]:
    st.subheader("üìã Resumo Estat√≠stico da Base Filtrada")
    st.write(df_filtrado.describe(include='all'))
    st.write("üí° N√∫mero de registros filtrados:", len(df_filtrado))

    # Bot√µes de download
    csv = df_filtrado.to_csv(index=False).encode('utf-8-sig')
    st.download_button("üì• Baixar CSV filtrado", data=csv, file_name="dados_filtrados.csv", mime="text/csv")

# ----- Aba 2: Distribui√ß√£o de Idade -----
with tabs[1]:
    st.subheader("üìà Distribui√ß√£o de Idade")
    fig_idade = px.histogram(
        df_filtrado, x="idade", nbins=20,
        title="Distribui√ß√£o de Idade", color_discrete_sequence=["#6ab7ff"]
    )
    st.plotly_chart(fig_idade, use_container_width=True)

# ----- Aba 3: Distribui√ß√£o de Sexo -----
with tabs[2]:
    st.subheader("üßç Distribui√ß√£o de Sexo")
    fig_sexo = px.pie(
        df_filtrado, names="sexo",
        title="Distribui√ß√£o de Sexo", color_discrete_sequence=px.colors.qualitative.Pastel
    )
    st.plotly_chart(fig_sexo, use_container_width=True)

# ----- Aba 4: Top 10 Categorias -----
with tabs[3]:
    st.subheader("üõçÔ∏è Top 10 Categorias Frequentadas")
    top_categorias = df_filtrado['categoria_frequentada'].value_counts().nlargest(10).reset_index()
    top_categorias.columns = ['categoria_frequentada', 'contagem']
    fig_cat = px.bar(
        top_categorias, x='contagem', y='categoria_frequentada',
        orientation='h', text='contagem', color='contagem', color_continuous_scale='Blues'
    )
    fig_cat.update_traces(texttemplate='%{text}', textposition='outside')
    fig_cat.update_layout(yaxis={'categoryorder':'total ascending'})
    st.plotly_chart(fig_cat, use_container_width=True)

# Removed "Idade Informada x Idade Calculada" tab

# =================== EXPORTA√á√ÉO HTML ===================
st.subheader("üìÇ Relat√≥rio HTML Interativo")
if st.button("üì• Gerar relat√≥rio HTML"):
    # Removed fig_disp from the list of figures to save
    pio.write_html([fig_idade, fig_sexo, fig_cat],
                   file='relatorio_interativo.html', auto_open=False)
    st.success("‚úÖ Relat√≥rio HTML gerado: 'relatorio_interativo.html'")

# =================== IMPORTS ===================
import pandas as pd
import plotly.express as px
import plotly.figure_factory as ff
import plotly.io as pio
import streamlit as st
from datetime import datetime

# =================== CARREGAR DADOS ===================
df = pd.read_csv('dados_relatorio_interativo.csv')

# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# =================== SIDEBAR FILTROS ===================
st.sidebar.title("Filtros")
sexo_filter = st.sidebar.multiselect(
    "Selecione o sexo:",
    options=df['sexo'].unique(),
    default=df['sexo'].unique()
)
idade_range = st.sidebar.slider(
    "Selecione faixa et√°ria:",
    int(df['idade'].min()), int(df['idade'].max()),
    (int(df['idade'].min()), int(df['idade'].max()))
)

df_filtrado = df[
    (df['sexo'].isin(sexo_filter)) &
    (df['idade'] >= idade_range[0]) &
    (df['idade'] <= idade_range[1])
]

# =================== T√çTULO ===================
st.title("üåé Dashboard Avan√ßado Geoespacial de Usu√°rios")

# =================== ABAS ===================
# Removed "Idade vs Calculada" tab as the plot is removed
tabs = st.tabs([
    "Resumo Estat√≠stico", "Idade", "Sexo",
    "Categorias", "Mapa", "Heatmap"
])

# ----- Aba 1: Resumo Estat√≠stico -----
with tabs[0]:
    st.subheader("üìã Resumo Estat√≠stico da Base Filtrada")
    st.write(df_filtrado.describe(include='all'))
    st.write("üí° N√∫mero de registros filtrados:", len(df_filtrado))
    csv = df_filtrado.to_csv(index=False).encode('utf-8-sig')
    st.download_button("üì• Baixar CSV filtrado", data=csv, file_name="dados_filtrados.csv", mime="text/csv")

# ----- Aba 2: Distribui√ß√£o de Idade -----
with tabs[1]:
    st.subheader("üìà Distribui√ß√£o de Idade")
    fig_idade = px.histogram(df_filtrado, x="idade", nbins=20, color_discrete_sequence=["#6ab7ff"])
    st.plotly_chart(fig_idade, use_container_width=True)

# ----- Aba 3: Distribui√ß√£o de Sexo -----
with tabs[2]:
    st.subheader("üßç Distribui√ß√£o de Sexo")
    fig_sexo = px.pie(df_filtrado, names="sexo", color_discrete_sequence=px.colors.qualitative.Pastel)
    st.plotly_chart(fig_sexo, use_container_width=True)

# ----- Aba 4: Top 10 Categorias -----
with tabs[3]:
    st.subheader("üõçÔ∏è Top 10 Categorias Frequentadas")
    top_categorias = df_filtrado['categoria_frequentada'].value_counts().nlargest(10).reset_index()
    top_categorias.columns = ['categoria_frequentada', 'contagem']
    fig_cat = px.bar(top_categorias, x='contagem', y='categoria_frequentada',
                     orientation='h', text='contagem', color='contagem', color_continuous_scale='Blues')
    fig_cat.update_traces(texttemplate='%{text}', textposition='outside')
    fig_cat.update_layout(yaxis={'categoryorder':'total ascending'})
    st.plotly_chart(fig_cat, use_container_width=True)

# Removed "Idade Informada x Idade Calculada" tab

# ----- Aba 6: Mapa de Usu√°rios por Bairro -----
with tabs[4]:
    st.subheader("üó∫Ô∏è Mapa de Usu√°rios por Bairro")
    # Necess√°rio ter latitude e longitude (exemplo simplificado usando cidade/bairro)
    # Aqui usamos geocodifica√ß√£o fict√≠cia para exemplo
    df_filtrado['lat'] =  -23.55  # latitude aproximada de SP
    df_filtrado['lon'] = -46.63   # longitude aproximada de SP
    fig_map = px.scatter_mapbox(df_filtrado, lat='lat', lon='lon', color='sexo',
                                hover_name='bairro_residencial',
                                hover_data=['categoria_frequentada','idade'],
                                zoom=10, height=500)
    fig_map.update_layout(mapbox_style="open-street-map")
    st.plotly_chart(fig_map, use_container_width=True)

# ----- Aba 7: Heatmap de Correla√ß√£o -----
with tabs[5]:
    st.subheader("üå°Ô∏è Heatmap de Correla√ß√£o")
    numeric_cols = df_filtrado.select_dtypes(include='number').columns
    corr_matrix = df_filtrado[numeric_cols].corr()
    fig_heat = ff.create_annotated_heatmap(
        z=corr_matrix.values,
        x=list(corr_matrix.columns),
        y=list(corr_matrix.index),
        colorscale='Blues'
    )
    st.plotly_chart(fig_heat, use_container_width=True)

# ----- Exporta√ß√£o HTML -----
st.subheader("üìÇ Relat√≥rio HTML Interativo")
if st.button("üì• Gerar relat√≥rio HTML"):
    # Removed fig_disp from the list of figures to save
    pio.write_html([fig_idade, fig_sexo, fig_cat, fig_map, fig_heat],
                   file='relatorio_geoespacial.html', auto_open=False)
    st.success("‚úÖ Relat√≥rio HTML gerado: 'relatorio_geoespacial.html'")

# =================== IMPORTS ===================
import pandas as pd
import plotly.express as px
import plotly.figure_factory as ff
import plotly.io as pio
import streamlit as st
from datetime import datetime
from geopy.geocoders import Nominatim
from geopy.extra.rate_limiter import RateLimiter

# =================== CARREGAR DADOS ===================
df = pd.read_csv('dados_relatorio_interativo.csv')

# Removed calculation of idade_calc and dif_idade as data_nascimento is not available
# df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
# df['dif_idade'] = df['idade'] - df['idade_calc']

# =================== GEOCODIFICA√á√ÉO ===================
st.sidebar.title("Geocodifica√ß√£o (opcional)")
geocode_enabled = st.sidebar.checkbox("Ativar geocodifica√ß√£o completa (pode demorar)")

if geocode_enabled:
    geolocator = Nominatim(user_agent="dashboard_geo")
    geocode = RateLimiter(geolocator.geocode, min_delay_seconds=1)

    # Criar coluna endere√ßo
    df['endereco'] = df['bairro_residencial'].astype(str) + ", " + df['cidade_residencial'].astype(str) + ", Brasil"

    # Inicializa colunas de latitude e longitude
    df['lat'] = None
    df['lon'] = None

    # Geocodifica√ß√£o iterativa
    for idx, row in df.iterrows():
        location = geocode(row['endereco'])
        if location:
            df.at[idx, 'lat'] = location.latitude
            df.at[idx, 'lon'] = location.longitude

# =================== SIDEBAR FILTROS ===================
sexo_filter = st.sidebar.multiselect(
    "Selecione o sexo:",
    options=df['sexo'].unique(),
    default=df['sexo'].unique()
)
idade_range = st.sidebar.slider(
    "Selecione faixa et√°ria:",
    int(df['idade'].min()), int(df['idade'].max()),
    (int(df['idade'].min()), int(df['idade'].max()))
)

df_filtrado = df[
    (df['sexo'].isin(sexo_filter)) &
    (df['idade'] >= idade_range[0]) &
    (df['idade'] <= idade_range[1])
]

# =================== T√çTULO ===================
st.title("üåé Dashboard Geoespacial de Usu√°rios ‚Äì Vers√£o Completa")

# =================== ABAS ===================
tabs = st.tabs([
    "Resumo Estat√≠stico", "Idade", "Sexo",
    "Categorias", "Mapa", "Heatmap", "Clusters"
])

# ----- Aba 1: Resumo Estat√≠stico -----
with tabs[0]:
    st.subheader("üìã Resumo Estat√≠stico da Base Filtrada")
    st.write(df_filtrado.describe(include='all'))
    st.write("üí° N√∫mero de registros filtrados:", len(df_filtrado))
    csv = df_filtrado.to_csv(index=False).encode('utf-8-sig')
    st.download_button("üì• Baixar CSV filtrado", data=csv, file_name="dados_filtrados.csv", mime="text/csv")

# ----- Aba 2: Distribui√ß√£o de Idade -----
with tabs[1]:
    st.subheader("üìà Distribui√ß√£o de Idade")
    fig_idade = px.histogram(df_filtrado, x="idade", nbins=20, color_discrete_sequence=["#6ab7ff"])
    st.plotly_chart(fig_idade, use_container_width=True)

# ----- Aba 3: Distribui√ß√£o de Sexo -----
with tabs[2]:
    st.subheader("üßç Distribui√ß√£o de Sexo")
    fig_sexo = px.pie(df_filtrado, names="sexo", color_discrete_sequence=px.colors.qualitative.Pastel)
    st.plotly_chart(fig_sexo, use_container_width=True)

# ----- Aba 4: Top 10 Categorias -----
with tabs[3]:
    st.subheader("üõçÔ∏è Top 10 Categorias Frequentadas")
    top_categorias = df_filtrado['categoria_frequentada'].value_counts().nlargest(10).reset_index()
    top_categorias.columns = ['categoria_frequentada', 'contagem']
    fig_cat = px.bar(top_categorias, x='contagem', y='categoria_frequentada',
                     orientation='h', text='contagem', color='contagem', color_continuous_scale='Blues')
    fig_cat.update_traces(texttemplate='%{text}', textposition='outside')
    fig_cat.update_layout(yaxis={'categoryorder':'total ascending'})
    st.plotly_chart(fig_cat, use_container_width=True)

# Removed "Idade Informada x Idade Calculada" tab

# ----- Aba 6: Mapa de Usu√°rios por Bairro -----
with tabs[4]:
    st.subheader("üó∫Ô∏è Mapa de Usu√°rios por Bairro")
    # Necess√°rio ter latitude e longitude (exemplo simplificado usando cidade/bairro)
    # Aqui usamos geocodifica√ß√£o fict√≠cia para exemplo
    df_filtrado['lat'] =  -23.55  # latitude aproximada de SP
    df_filtrado['lon'] = -46.63   # longitude aproximada de SP
    fig_map = px.scatter_mapbox(df_filtrado, lat='lat', lon='lon', color='sexo',
                                hover_name='bairro_residencial',
                                hover_data=['categoria_frequentada','idade'],
                                zoom=10, height=500)
    fig_map.update_layout(mapbox_style="open-street-map")
    st.plotly_chart(fig_map, use_container_width=True)

# ----- Aba 7: Heatmap de Correla√ß√£o -----
with tabs[5]:
    st.subheader("üå°Ô∏è Heatmap de Correla√ß√£o")
    numeric_cols = df_filtrado.select_dtypes(include='number').columns
    corr_matrix = df_filtrado[numeric_cols].corr()
    fig_heat = ff.create_annotated_heatmap(
        z=corr_matrix.values,
        x=list(corr_matrix.columns),
        y=list(corr_matrix.index),
        colorscale='Blues'
    )
    st.plotly_chart(fig_heat, use_container_width=True)

# ----- Aba 8: Clusters de Categorias -----
with tabs[6]:
    st.subheader("üìå Clusters de Categorias por Regi√£o")
    if 'lat' in df_filtrado.columns and df_filtrado['lat'].notnull().any():
        fig_cluster = px.scatter_mapbox(
            df_filtrado, lat='lat', lon='lon', color='categoria_frequentada',
            hover_name='bairro_residencial',
            hover_data=['idade','sexo'],
            zoom=4, height=600
        )
        fig_cluster.update_layout(mapbox_style="open-street-map")
        st.plotly_chart(fig_cluster, use_container_width=True)
    else:
        st.info("Ative a geocodifica√ß√£o na barra lateral para visualizar clusters.")

# ----- Exporta√ß√£o HTML -----
st.subheader("üìÇ Relat√≥rio HTML Interativo")
if st.button("üì• Gerar relat√≥rio HTML"):
    # Removed fig_disp from the list of figures to save
    pio.write_html([fig_idade, fig_sexo, fig_cat, fig_map, fig_heat, fig_cluster],
                   file='relatorio_geoespacial_completo.html', auto_open=False)
    st.success("‚úÖ Relat√≥rio HTML gerado: 'relatorio_geoespacial_completo.html'")

import pandas as pd
from datetime import datetime
import re

# -----------------------------
# 1Ô∏è‚É£ Carregar dados
# -----------------------------
df = pd.read_csv('/content/PicMoney-Base_Cadastral_de_Players-10_000 linhas (1).csv', sep=';')

# Convert 'data_nascimento' to datetime objects
df['data_nascimento'] = pd.to_datetime(df['data_nascimento'], errors='coerce', dayfirst=True)

# -----------------------------
# 2Ô∏è‚É£ Limpeza
# -----------------------------
# Remover duplicatas
df = df.drop_duplicates()

# Conferir consist√™ncia idade x data de nascimento
df['idade_calc'] = datetime.now().year - df['data_nascimento'].dt.year
df['dif_idade'] = df['idade'] - df['idade_calc']
df['idade_inconsistente'] = df['dif_idade'].abs() > 1

# -----------------------------
# 3Ô∏è‚É£ Uniformiza√ß√£o
# -----------------------------
str_cols = [
    'sexo', 'cidade_residencial', 'bairro_residencial',
    'cidade_trabalho', 'bairro_trabalho', 'cidade_escola',
    'bairro_escola', 'categoria_frequentada'
]

for col in str_cols:
    df[col] = df[col].astype(str).str.strip().str.title()

# Padronizar sexo
df['sexo'] = df['sexo'].replace({'F':'Feminino','M':'Masculino'})

# -----------------------------
# 4Ô∏è‚É£ Deriva√ß√£o de colunas
# -----------------------------
# Endere√ßo completo para geocodifica√ß√£o futura
df['endereco_completo'] = df['bairro_residencial'] + ", " + df['cidade_residencial'] + ", Brasil"

# -----------------------------
# 5Ô∏è‚É£ Integra√ß√£o (opcional)
# -----------------------------
# Exemplo: unindo com dataset de engajamento
# df = df.merge(df_engajamento, on='celular', how='left')

# -----------------------------
# 6Ô∏è‚É£ Formata√ß√£o de tipos
# -----------------------------
df['celular'] = df['celular'].astype(str)
df['idade'] = df['idade'].astype(int)
df['sexo'] = df['sexo'].astype('category')
df['categoria_frequentada'] = df['categoria_frequentada'].astype('category')

# Ordenar colunas
df = df[[
    'celular', 'data_nascimento', 'idade', 'idade_calc', 'dif_idade', 'idade_inconsistente',
    'sexo', 'cidade_residencial', 'bairro_residencial',
    'cidade_trabalho', 'bairro_trabalho', 'cidade_escola',
    'bairro_escola', 'categoria_frequentada', 'endereco_completo'
]]

# -----------------------------
# 7Ô∏è‚É£ Valida√ß√µes finais
# -----------------------------
# Valores faltantes
print("Valores faltantes por coluna:")
print(df.isna().sum())

# Celulares fora do padr√£o
mask = df['celular'].str.match(r'^\(\d{2}\) \d{4,5}-\d{4}$')
print("Celulares fora do padr√£o:", (~mask).sum())

# Idades inconsistentes
print("Linhas com idade inconsistente:", df['idade_inconsistente'].sum())

# -----------------------------
# 8Ô∏è‚É£ Salvar CSV limpo
# -----------------------------
df.to_csv('dados_limpos.csv', index=False)
print("Pipeline finalizado! CSV limpo salvo como 'dados_limpos.csv'.")

import pandas as pd
from datetime import datetime
import re
from geopy.geocoders import Nominatim
from geopy.extra.rate_limiter import RateLimiter
from concurrent.futures import ThreadPoolExecutor
import matplotlib.pyplot as plt
import seaborn as sns

# -----------------------------
# 1Ô∏è‚É£ Carregar dados
# -----------------------------
df = pd.read_csv('/content/PicMoney-Base_Cadastral_de_Players-10_000 linhas (1).csv', sep=';')

# Convert 'data_nascimento' to datetime objects, coercing errors
df['data_nascimento'] = pd.to_datetime(df['data_nascimento'], errors='coerce', dayfirst=True)

# -----------------------------
# 2Ô∏è‚É£ Limpeza e padroniza√ß√£o
# -----------------------------
df = df.drop_duplicates()

# Idade calculada e inconsist√™ncia
# Filter out NaT values before calculating year to avoid errors
df_valid_dates = df.dropna(subset=['data_nascimento'])
df['idade_calc'] = datetime.now().year - df_valid_dates['data_nascimento'].dt.year
df['dif_idade'] = df['idade'] - df['idade_calc']
df['idade_inconsistente'] = df['dif_idade'].abs() > 1

str_cols = [
    'sexo', 'cidade_residencial', 'bairro_residencial',
    'cidade_trabalho', 'bairro_trabalho', 'cidade_escola',
    'bairro_escola', 'categoria_frequentada'
]

for col in str_cols:
    df[col] = df[col].astype(str).str.strip().str.title()

df['sexo'] = df['sexo'].replace({'F':'Feminino','M':'Masculino'})

# Endere√ßo completo
df['endereco_completo'] = df['bairro_residencial'] + ", " + df['cidade_residencial'] + ", Brasil"

# -----------------------------
# 3Ô∏è‚É£ Geocodifica√ß√£o paralela
# -----------------------------
geolocator = Nominatim(user_agent="pipeline_geo")
geocode = RateLimiter(geolocator.geocode, min_delay_seconds=0.5)

def geocode_address(endereco):
    try:
        loc = geocode(endereco)
        if loc:
            return pd.Series([loc.latitude, loc.longitude])
    except Exception as e:
        print(f"Geocoding error for address '{endereco}': {e}") # Added error message for geocoding
        pass
    return pd.Series([None, None])

# Filter out rows with NaNs in 'endereco_completo' before geocoding
addresses_to_geocode = df.dropna(subset=['endereco_completo'])['endereco_completo'].tolist()

with ThreadPoolExecutor(max_workers=10) as executor:
    results = list(executor.map(geocode_address, addresses_to_geocode))

# Create a new DataFrame for geocoding results with the same index as the original df_valid_dates
geocoded_results_df = pd.DataFrame(results, index=df.dropna(subset=['endereco_completo']).index, columns=['lat', 'lon'])

# Update the original DataFrame with geocoding results
df[['lat', 'lon']] = geocoded_results_df[['lat', 'lon']]


# -----------------------------
# 4Ô∏è‚É£ Formata√ß√£o de tipos
# -----------------------------
df['celular'] = df['celular'].astype(str)
# df['idade'] = df['idade'].astype(int) # This might cause error if idade is NaN due to invalid data_nascimento
df['sexo'] = df['sexo'].astype('category')
df['categoria_frequentada'] = df['categoria_frequentada'].astype('category')

# Handle potential NaNs in 'idade' before converting to int - convert to nullable integer type
df['idade'] = df['idade'].astype('Int64')


# -----------------------------
# 5Ô∏è‚É£ Valida√ß√µes
# -----------------------------
mask = df['celular'].str.match(r'^\(\d{2}\) \d{4,5}-\d{4}$')
print("Celulares fora do padr√£o:", (~mask).sum())
print("Linhas com idade inconsistente:", df['idade_inconsistente'].sum())
print("\nValores faltantes por coluna:")
print(df.isna().sum())

# -----------------------------
# 6Ô∏è‚É£ Estat√≠sticas e gr√°ficos
# -----------------------------
sns.set(style="whitegrid")

# Distribution of age - handle potential NaNs in idade
plt.figure(figsize=(10,5))
sns.histplot(df['idade'].dropna(), bins=20, kde=True) # Drop NaNs for plotting
plt.title("Distribui√ß√£o de Idade")
plt.xlabel("Idade")
plt.ylabel("Contagem")
plt.show()

# Count by sex
plt.figure(figsize=(6,4))
sns.countplot(x='sexo', data=df)
plt.title("Contagem por Sexo")
plt.show()

# Count by category (top 10)
plt.figure(figsize=(12,6))
top_cats = df['categoria_frequentada'].value_counts().nlargest(10).index
sns.countplot(y='categoria_frequentada', data=df[df['categoria_frequentada'].isin(top_cats)], order=top_cats)
plt.title("Top 10 Categorias Frequentadas")
plt.show()

# Map of geographic distribution - handle potential NaNs in lat/lon
plt.figure(figsize=(8,6))
sns.scatterplot(x='lon', y='lat', hue='sexo', data=df.dropna(subset=['lat', 'lon']), alpha=0.6) # Drop NaNs for plotting
plt.title("Distribui√ß√£o Geogr√°fica dos Usu√°rios")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

# -----------------------------
# 7Ô∏è‚É£ Salvar CSV final
# -----------------------------
df.to_csv('dados_limpos_geocodificados_visualizados.csv', index=False)
print("\nPipeline completo finalizado! CSV salvo como 'dados_limpos_geocodificados_visualizados.csv'.")